import { getContext, onDestroy, setContext } from 'svelte';
import { createStoreContext } from './store-context.svelte.js';
import { fetchProviderPlugins } from './provider-context.svelte.js';
const foldPlugins = (parameters) => {
    const { store, plugins } = parameters;
    let root = new Proxy(store, {
        get(target) {
            // @ts-expect-error: https://javascript.info/proxy#private-fields
            // eslint-disable-next-line prefer-rest-params
            const value = Reflect.get(...arguments);
            if (typeof value === 'function')
                return value.bind(target);
            return value;
        }
    });
    plugins.map((plugin) => {
        plugin.setup?.(root);
        const proxy = new Proxy(root, {
            get: plugin.get,
            set: plugin.set,
            has: plugin.has
        });
        root = proxy;
    });
    return root;
};
/**
 * Create a reactive data store factory.
 *
 * The initial state of the data store should be described using the anonymous
 * class declaration syntax inside a `.svelte.ts` file. All features pertaining
 * to Svelte and ES6 classes are available and highly encouraged.
 *
 * Autocompletion for optional store APIs can be implemented by importing the
 * `Hooks` type and declaring `class implements Hooks`
 *
 * @param setup Anonymous class declaration describing the initial state.
 * @param plugins An array of `SinaPlugin`s.
 */
export const store = (setup, plugins = []) => {
    const key = Symbol();
    /**
     * Fetch an instance of the data store.
     *
     * If a parent/provider data store exists higher up within the component tree
     * then that instance will be used. Otherwise, a fresh instance of this data
     * store is created and assumes responsibility of being the provider data
     * store.
     *
     * @param label Optional debug label.
     */
    return (label) => {
        let context = getContext(key);
        if (context !== undefined)
            return context;
        const data = new setup();
        const store = Object.assign(data, createStoreContext({ state: data }));
        const proxy = foldPlugins({
            store,
            plugins: [...fetchProviderPlugins(), ...plugins]
        });
        context = setContext(key, proxy);
        if (label)
            proxy.$label = label;
        /*
      We want to do this self assignment in order to be consistent for the
      proxy traps that are listening for the particular scenario of post label
      assignment. By not doing this, it becomes slightly less reliable to use
      this method.
     */
        // eslint-disable-next-line no-self-assign
        else if (proxy.$label)
            proxy.$label = proxy.$label;
        else
            void null;
        if ('$cleanup' in store)
            onDestroy(() => store.$cleanup?.());
        return context;
    };
};
/**
 * Utility function to label provider stores in `<MultiProvider />` components.
 *
 * @example
 * ```svelte
 * <script lang="ts">
 *   import { MultiProvider, provider } from "sina";
 *   import { useCounterStore } from "./stores/counter.ts";
 * </script>
 *
 * <MultiProvider providers={[provider`counter`(useCounterStore)]} />
 * ```
 */
export const provider = (template) => (provider) => () => void provider(template[0]);
